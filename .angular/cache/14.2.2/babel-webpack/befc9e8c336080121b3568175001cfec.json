{"ast":null,"code":"import * as i1 from 'rxjs';\nimport { Subject, of, Observable, ReplaySubject, combineLatest, fromEvent } from 'rxjs';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, inject, InjectFlags, LOCALE_ID, Injectable, Inject, Component, ChangeDetectionStrategy, EventEmitter, Input, Output, HostBinding, ContentChildren, Optional, NgModule } from '@angular/core';\nimport { mergeMap, map, switchMap, debounceTime } from 'rxjs/operators'; /// <reference path=\"./types.ts\" />\n\nconst _c0 = [\"*\"];\nconst _c1 = \"[_nghost-%COMP%]{width:-webkit-fit-content;width:-moz-fit-content;width:fit-content;display:block}\";\n\nclass ChartEditorRef {\n  constructor(editor) {\n    this.editor = editor;\n    this.doneSubject = new Subject();\n    this.addEventListeners();\n  }\n  /**\n   * Gets an observable that is notified when the dialog is saved.\n   * Emits either the result if the dialog was saved or `null` if editing was cancelled.\n   */\n\n\n  afterClosed() {\n    return this.doneSubject.asObservable();\n  }\n  /**\n   * Stops editing the chart and closes the dialog.\n   */\n\n\n  cancel() {\n    this.editor.closeDialog();\n  }\n\n  addEventListeners() {\n    google.visualization.events.addOneTimeListener(this.editor, 'ok', () => {\n      google.visualization.events.removeAllListeners(this.editor);\n      const updatedChartWrapper = this.editor.getChartWrapper();\n      this.doneSubject.next(updatedChartWrapper);\n      this.doneSubject.complete();\n    });\n    google.visualization.events.addOneTimeListener(this.editor, 'cancel', () => {\n      google.visualization.events.removeAllListeners(this.editor);\n      this.doneSubject.next(null);\n      this.doneSubject.complete();\n    });\n  }\n\n}\n\nvar ChartType = /*#__PURE__*/(() => {\n  (function (ChartType) {\n    ChartType[\"AnnotationChart\"] = \"AnnotationChart\";\n    ChartType[\"AreaChart\"] = \"AreaChart\";\n    ChartType[\"Bar\"] = \"Bar\";\n    ChartType[\"BarChart\"] = \"BarChart\";\n    ChartType[\"BubbleChart\"] = \"BubbleChart\";\n    ChartType[\"Calendar\"] = \"Calendar\";\n    ChartType[\"CandlestickChart\"] = \"CandlestickChart\";\n    ChartType[\"ColumnChart\"] = \"ColumnChart\";\n    ChartType[\"ComboChart\"] = \"ComboChart\";\n    ChartType[\"PieChart\"] = \"PieChart\";\n    ChartType[\"Gantt\"] = \"Gantt\";\n    ChartType[\"Gauge\"] = \"Gauge\";\n    ChartType[\"GeoChart\"] = \"GeoChart\";\n    ChartType[\"Histogram\"] = \"Histogram\";\n    ChartType[\"Line\"] = \"Line\";\n    ChartType[\"LineChart\"] = \"LineChart\";\n    ChartType[\"Map\"] = \"Map\";\n    ChartType[\"OrgChart\"] = \"OrgChart\";\n    ChartType[\"Sankey\"] = \"Sankey\";\n    ChartType[\"Scatter\"] = \"Scatter\";\n    ChartType[\"ScatterChart\"] = \"ScatterChart\";\n    ChartType[\"SteppedAreaChart\"] = \"SteppedAreaChart\";\n    ChartType[\"Table\"] = \"Table\";\n    ChartType[\"Timeline\"] = \"Timeline\";\n    ChartType[\"TreeMap\"] = \"TreeMap\";\n    ChartType[\"WordTree\"] = \"wordtree\";\n  })(ChartType || (ChartType = {}));\n\n  return ChartType;\n})();\nconst ChartTypesToPackages = {\n  [ChartType.AnnotationChart]: 'annotationchart',\n  [ChartType.AreaChart]: 'corechart',\n  [ChartType.Bar]: 'bar',\n  [ChartType.BarChart]: 'corechart',\n  [ChartType.BubbleChart]: 'corechart',\n  [ChartType.Calendar]: 'calendar',\n  [ChartType.CandlestickChart]: 'corechart',\n  [ChartType.ColumnChart]: 'corechart',\n  [ChartType.ComboChart]: 'corechart',\n  [ChartType.PieChart]: 'corechart',\n  [ChartType.Gantt]: 'gantt',\n  [ChartType.Gauge]: 'gauge',\n  [ChartType.GeoChart]: 'geochart',\n  [ChartType.Histogram]: 'corechart',\n  [ChartType.Line]: 'line',\n  [ChartType.LineChart]: 'corechart',\n  [ChartType.Map]: 'map',\n  [ChartType.OrgChart]: 'orgchart',\n  [ChartType.Sankey]: 'sankey',\n  [ChartType.Scatter]: 'scatter',\n  [ChartType.ScatterChart]: 'corechart',\n  [ChartType.SteppedAreaChart]: 'corechart',\n  [ChartType.Table]: 'table',\n  [ChartType.Timeline]: 'timeline',\n  [ChartType.TreeMap]: 'treemap',\n  [ChartType.WordTree]: 'wordtree'\n};\n\nfunction getPackageForChart(type) {\n  return ChartTypesToPackages[type];\n}\n\nfunction getDefaultConfig() {\n  return {\n    version: 'current',\n    safeMode: false\n  };\n}\n\nconst GOOGLE_CHARTS_CONFIG = new InjectionToken('GOOGLE_CHARTS_CONFIG');\nconst GOOGLE_CHARTS_LAZY_CONFIG = new InjectionToken('GOOGLE_CHARTS_LAZY_CONFIG', {\n  providedIn: 'root',\n  factory: () => {\n    const configFromModule = inject(GOOGLE_CHARTS_CONFIG, InjectFlags.Optional);\n    return of({ ...getDefaultConfig(),\n      ...(configFromModule || {})\n    });\n  }\n});\nlet ScriptLoaderService = /*#__PURE__*/(() => {\n  class ScriptLoaderService {\n    constructor(zone, localeId, config$) {\n      this.zone = zone;\n      this.localeId = localeId;\n      this.config$ = config$;\n      this.scriptSource = 'https://www.gstatic.com/charts/loader.js';\n      this.scriptLoadSubject = new Subject();\n    }\n    /**\n     * Checks whether `google.charts` is available.\n     *\n     * If not, it can be loaded by calling `loadChartPackages`.\n     *\n     * @returns `true` if `google.charts` is available, `false` otherwise.\n     */\n\n\n    isGoogleChartsAvailable() {\n      if (typeof google === 'undefined' || typeof google.charts === 'undefined') {\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * Loads the Google Chart script and the provided chart packages.\n     * Can be called multiple times to load more packages.\n     *\n     * When called without any arguments, this will just load the default package\n     * containing the namespaces `google.charts` and `google.visualization` without any charts.\n     *\n     * @param packages The packages to load.\n     * @returns A stream emitting as soon as the chart packages are loaded.\n     */\n\n\n    loadChartPackages(...packages) {\n      return this.loadGoogleCharts().pipe(mergeMap(() => this.config$), map(config => {\n        return { ...getDefaultConfig(),\n          ...(config || {})\n        };\n      }), switchMap(googleChartsConfig => {\n        return new Observable(observer => {\n          const config = {\n            packages,\n            language: this.localeId,\n            mapsApiKey: googleChartsConfig.mapsApiKey,\n            safeMode: googleChartsConfig.safeMode\n          };\n          google.charts.load(googleChartsConfig.version, config);\n          google.charts.setOnLoadCallback(() => {\n            this.zone.run(() => {\n              observer.next();\n              observer.complete();\n            });\n          });\n        });\n      }));\n    }\n    /**\n     * Loads the Google Charts script. After the script is loaded, `google.charts` is defined.\n     *\n     * @returns A stream emitting as soon as loading has completed.\n     * If the google charts script is already loaded, the stream emits immediately.\n     */\n\n\n    loadGoogleCharts() {\n      if (this.isGoogleChartsAvailable()) {\n        return of(undefined);\n      } else if (!this.isLoadingGoogleCharts()) {\n        const script = this.createGoogleChartsScript();\n\n        script.onload = () => {\n          this.zone.run(() => {\n            this.scriptLoadSubject.next();\n            this.scriptLoadSubject.complete();\n          });\n        };\n\n        script.onerror = () => {\n          this.zone.run(() => {\n            console.error('Failed to load the google charts script!');\n            this.scriptLoadSubject.error(new Error('Failed to load the google charts script!'));\n          });\n        };\n      }\n\n      return this.scriptLoadSubject.asObservable();\n    }\n\n    isLoadingGoogleCharts() {\n      return this.getGoogleChartsScript() != null;\n    }\n\n    getGoogleChartsScript() {\n      const pageScripts = Array.from(document.getElementsByTagName('script'));\n      return pageScripts.find(script => script.src === this.scriptSource);\n    }\n\n    createGoogleChartsScript() {\n      const script = document.createElement('script');\n      script.type = 'text/javascript';\n      script.src = this.scriptSource;\n      script.async = true;\n      document.getElementsByTagName('head')[0].appendChild(script);\n      return script;\n    }\n\n  }\n\n  ScriptLoaderService.ɵfac = function ScriptLoaderService_Factory(t) {\n    return new (t || ScriptLoaderService)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(LOCALE_ID), i0.ɵɵinject(GOOGLE_CHARTS_LAZY_CONFIG));\n  };\n\n  ScriptLoaderService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ScriptLoaderService,\n    factory: ScriptLoaderService.ɵfac\n  });\n  return ScriptLoaderService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); /// <reference path=\"./types.ts\" />\n\n\nlet ChartEditorComponent = /*#__PURE__*/(() => {\n  class ChartEditorComponent {\n    constructor(scriptLoaderService) {\n      this.scriptLoaderService = scriptLoaderService;\n      this.initializedSubject = new Subject();\n    }\n    /**\n     * Emits as soon as the chart editor is fully initialized.\n     */\n\n\n    get initialized$() {\n      return this.initializedSubject.asObservable();\n    }\n\n    ngOnInit() {\n      this.scriptLoaderService.loadChartPackages('charteditor').subscribe(() => {\n        this.editor = new google.visualization.ChartEditor();\n        this.initializedSubject.next(this.editor);\n        this.initializedSubject.complete();\n      });\n    }\n\n    editChart(component, options) {\n      if (!component.chartWrapper) {\n        throw new Error('Chart wrapper is `undefined`. Please wait for the `initialized$` observable before trying to edit a chart.');\n      }\n\n      if (!this.editor) {\n        throw new Error('Chart editor is `undefined`. Please wait for the `initialized$` observable before trying to edit a chart.');\n      }\n\n      const handle = new ChartEditorRef(this.editor);\n      this.editor.openDialog(component.chartWrapper, options || {});\n      handle.afterClosed().subscribe(result => {\n        if (result) {\n          component.chartWrapper = result;\n        }\n      });\n      return handle;\n    }\n\n  }\n\n  ChartEditorComponent.ɵfac = function ChartEditorComponent_Factory(t) {\n    return new (t || ChartEditorComponent)(i0.ɵɵdirectiveInject(ScriptLoaderService));\n  };\n\n  ChartEditorComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ChartEditorComponent,\n    selectors: [[\"chart-editor\"]],\n    hostAttrs: [1, \"chart-editor\"],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function ChartEditorComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return ChartEditorComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet DataTableService = /*#__PURE__*/(() => {\n  class DataTableService {\n    create(data, columns, formatters) {\n      if (data == null) {\n        return undefined;\n      }\n\n      let firstRowIsData = true;\n\n      if (columns != null) {\n        firstRowIsData = false;\n      }\n\n      const dataTable = google.visualization.arrayToDataTable(this.getDataAsTable(data, columns), firstRowIsData);\n\n      if (formatters) {\n        this.applyFormatters(dataTable, formatters);\n      }\n\n      return dataTable;\n    }\n\n    getDataAsTable(data, columns) {\n      if (columns) {\n        return [columns, ...data];\n      } else {\n        return data;\n      }\n    }\n\n    applyFormatters(dataTable, formatters) {\n      for (const val of formatters) {\n        val.formatter.format(dataTable, val.colIndex);\n      }\n    }\n\n  }\n\n  DataTableService.ɵfac = function DataTableService_Factory(t) {\n    return new (t || DataTableService)();\n  };\n\n  DataTableService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DataTableService,\n    factory: DataTableService.ɵfac,\n    providedIn: 'root'\n  });\n  return DataTableService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generates a random ID which can be used to uniquely identify an element.\n */\n\n\nfunction generateRandomId() {\n  // Math.random should be unique because of its seeding algorithm.\n  // Convert it to base 36 (numbers + letters), and grab the first 9 characters\n  // after the decimal.\n  return '_' + Math.random().toString(36).substr(2, 9);\n}\n\nvar FilterType = /*#__PURE__*/(() => {\n  (function (FilterType) {\n    FilterType[\"Category\"] = \"CategoryFilter\";\n    FilterType[\"ChartRange\"] = \"ChartRangeFilter\";\n    FilterType[\"DateRange\"] = \"DateRangeFilter\";\n    FilterType[\"NumberRange\"] = \"NumberRangeFilter\";\n    FilterType[\"String\"] = \"StringFilter\";\n  })(FilterType || (FilterType = {}));\n\n  return FilterType;\n})();\nlet ControlWrapperComponent = /*#__PURE__*/(() => {\n  class ControlWrapperComponent {\n    constructor(loaderService) {\n      this.loaderService = loaderService;\n      /**\n       * Emits when an error occurs when attempting to render the control.\n       */\n\n      this.error = new EventEmitter();\n      /**\n       * The control is ready to accept user interaction and for external method calls.\n       *\n       * Alternatively, you can listen for a ready event on the dashboard holding the control\n       * and call control methods only after the event was fired.\n       */\n\n      this.ready = new EventEmitter();\n      /**\n       * Emits when the user interacts with the control, affecting its state.\n       * For example, a `stateChange` event will be emitted whenever you move the thumbs of a range slider control.\n       *\n       * To retrieve an updated control state after the event fired, call `ControlWrapper.getState()`.\n       */\n\n      this.stateChange = new EventEmitter();\n      /**\n       * A generated id assigned to this components DOM element.\n       */\n\n      this.id = generateRandomId();\n      this.wrapperReadySubject = new ReplaySubject(1);\n    }\n    /**\n     * Emits after the `ControlWrapper` was created.\n     */\n\n\n    get wrapperReady$() {\n      return this.wrapperReadySubject.asObservable();\n    }\n\n    get controlWrapper() {\n      if (!this._controlWrapper) {\n        throw new Error(`Cannot access the control wrapper before it being initialized.`);\n      }\n\n      return this._controlWrapper;\n    }\n\n    ngOnInit() {\n      this.loaderService.loadChartPackages('controls').subscribe(() => {\n        this.createControlWrapper();\n      });\n    }\n\n    ngOnChanges(changes) {\n      if (!this._controlWrapper) {\n        return;\n      }\n\n      if (changes.type) {\n        this._controlWrapper.setControlType(this.type);\n      }\n\n      if (changes.options) {\n        this._controlWrapper.setOptions(this.options || {});\n      }\n\n      if (changes.state) {\n        this._controlWrapper.setState(this.state || {});\n      }\n    }\n\n    createControlWrapper() {\n      this._controlWrapper = new google.visualization.ControlWrapper({\n        containerId: this.id,\n        controlType: this.type,\n        state: this.state,\n        options: this.options\n      });\n      this.addEventListeners();\n      this.wrapperReadySubject.next(this._controlWrapper);\n    }\n\n    addEventListeners() {\n      google.visualization.events.removeAllListeners(this._controlWrapper);\n      google.visualization.events.addListener(this._controlWrapper, 'ready', event => this.ready.emit(event));\n      google.visualization.events.addListener(this._controlWrapper, 'error', event => this.error.emit(event));\n      google.visualization.events.addListener(this._controlWrapper, 'statechange', event => this.stateChange.emit(event));\n    }\n\n  }\n\n  ControlWrapperComponent.ɵfac = function ControlWrapperComponent_Factory(t) {\n    return new (t || ControlWrapperComponent)(i0.ɵɵdirectiveInject(ScriptLoaderService));\n  };\n\n  ControlWrapperComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ControlWrapperComponent,\n    selectors: [[\"control-wrapper\"]],\n    hostAttrs: [1, \"control-wrapper\"],\n    hostVars: 1,\n    hostBindings: function ControlWrapperComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵhostProperty(\"id\", ctx.id);\n      }\n    },\n    inputs: {\n      for: \"for\",\n      type: \"type\",\n      options: \"options\",\n      state: \"state\"\n    },\n    outputs: {\n      error: \"error\",\n      ready: \"ready\",\n      stateChange: \"stateChange\"\n    },\n    exportAs: [\"controlWrapper\"],\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 0,\n    vars: 0,\n    template: function ControlWrapperComponent_Template(rf, ctx) {},\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return ControlWrapperComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet DashboardComponent = /*#__PURE__*/(() => {\n  class DashboardComponent {\n    constructor(element, loaderService, dataTableService) {\n      this.element = element;\n      this.loaderService = loaderService;\n      this.dataTableService = dataTableService;\n      /**\n       * The dashboard has completed drawing and is ready to accept changes.\n       *\n       * The ready event will also fire:\n       * - after the completion of a dashboard refresh triggered by a user or programmatic interaction with one of the controls,\n       * - after redrawing any chart on the dashboard.\n       */\n\n      this.ready = new EventEmitter();\n      /**\n       * Emits when an error occurs when attempting to render the dashboard.\n       * One or more of the controls and charts that are part of the dashboard may have failed rendering.\n       */\n\n      this.error = new EventEmitter();\n      this.initialized = false;\n    }\n\n    ngOnInit() {\n      this.loaderService.loadChartPackages('controls').subscribe(() => {\n        this.dataTable = this.dataTableService.create(this.data, this.columns, this.formatters);\n        this.createDashboard();\n        this.initialized = true;\n      });\n    }\n\n    ngOnChanges(changes) {\n      if (!this.initialized) {\n        return;\n      }\n\n      if (changes.data || changes.columns || changes.formatters) {\n        this.dataTable = this.dataTableService.create(this.data, this.columns, this.formatters);\n        this.dashboard.draw(this.dataTable);\n      }\n    }\n\n    createDashboard() {\n      // TODO: This should happen in the control wrapper\n      // However, I don't yet know how to do this because then `bind()` would get called multiple times\n      // for the same control if something changes. This is not supported by google charts as far as I can tell\n      // from their source code.\n      const controlWrappersReady$ = this.controlWrappers.map(control => control.wrapperReady$);\n      const chartsReady$ = this.controlWrappers.map(control => control.for).map(charts => {\n        if (Array.isArray(charts)) {\n          // CombineLatest waits for all observables\n          return combineLatest(charts.map(chart => chart.wrapperReady$));\n        } else {\n          return charts.wrapperReady$;\n        }\n      }); // We have to wait for all chart wrappers and control wrappers to be initialized\n      // before we can compose them together to create the dashboard\n\n      combineLatest([...controlWrappersReady$, ...chartsReady$]).subscribe(() => {\n        this.dashboard = new google.visualization.Dashboard(this.element.nativeElement);\n        this.initializeBindings();\n        this.registerEvents();\n        this.dashboard.draw(this.dataTable);\n      });\n    }\n\n    registerEvents() {\n      google.visualization.events.removeAllListeners(this.dashboard);\n\n      const registerDashEvent = (object, eventName, callback) => {\n        google.visualization.events.addListener(object, eventName, callback);\n      };\n\n      registerDashEvent(this.dashboard, 'ready', () => this.ready.emit());\n      registerDashEvent(this.dashboard, 'error', error => this.error.emit(error));\n    }\n\n    initializeBindings() {\n      this.controlWrappers.forEach(control => {\n        if (Array.isArray(control.for)) {\n          const chartWrappers = control.for.map(chart => chart.chartWrapper);\n          this.dashboard.bind(control.controlWrapper, chartWrappers);\n        } else {\n          this.dashboard.bind(control.controlWrapper, control.for.chartWrapper);\n        }\n      });\n    }\n\n  }\n\n  DashboardComponent.ɵfac = function DashboardComponent_Factory(t) {\n    return new (t || DashboardComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(ScriptLoaderService), i0.ɵɵdirectiveInject(DataTableService));\n  };\n\n  DashboardComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: DashboardComponent,\n    selectors: [[\"dashboard\"]],\n    contentQueries: function DashboardComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ControlWrapperComponent, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.controlWrappers = _t);\n      }\n    },\n    hostAttrs: [1, \"dashboard\"],\n    inputs: {\n      data: \"data\",\n      columns: \"columns\",\n      formatters: \"formatters\"\n    },\n    outputs: {\n      ready: \"ready\",\n      error: \"error\"\n    },\n    exportAs: [\"dashboard\"],\n    features: [i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function DashboardComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return DashboardComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet GoogleChartComponent = /*#__PURE__*/(() => {\n  class GoogleChartComponent {\n    constructor(element, scriptLoaderService, dataTableService, dashboard) {\n      this.element = element;\n      this.scriptLoaderService = scriptLoaderService;\n      this.dataTableService = dataTableService;\n      this.dashboard = dashboard;\n      /**\n       * The chart-specific options. All options listen in the Google Charts documentation applying\n       * to the chart type specified can be used here.\n       */\n\n      this.options = {};\n      /**\n       * If this is set to `true`, the chart will be redrawn if the browser window is resized.\n       * Defaults to `false` and should only be used when specifying the width or height of the chart\n       * in percent.\n       *\n       * Note that this can impact performance.\n       */\n\n      this.dynamicResize = false;\n      this.ready = new EventEmitter();\n      this.error = new EventEmitter();\n      this.select = new EventEmitter();\n      this.mouseover = new EventEmitter();\n      this.mouseleave = new EventEmitter();\n      this.wrapperReadySubject = new ReplaySubject(1);\n      this.initialized = false;\n      this.eventListeners = new Map();\n    }\n\n    get chart() {\n      return this.chartWrapper.getChart();\n    }\n\n    get wrapperReady$() {\n      return this.wrapperReadySubject.asObservable();\n    }\n\n    get chartWrapper() {\n      if (!this.wrapper) {\n        throw new Error('Trying to access the chart wrapper before it was fully initialized');\n      }\n\n      return this.wrapper;\n    }\n\n    set chartWrapper(wrapper) {\n      this.wrapper = wrapper;\n      this.drawChart();\n    }\n\n    ngOnInit() {\n      // We don't need to load any chart packages, the chart wrapper will handle this for us\n      this.scriptLoaderService.loadChartPackages(getPackageForChart(this.type)).subscribe(() => {\n        this.dataTable = this.dataTableService.create(this.data, this.columns, this.formatters); // Only ever create the wrapper once to allow animations to happen when something changes.\n\n        this.wrapper = new google.visualization.ChartWrapper({\n          container: this.element.nativeElement,\n          chartType: this.type,\n          dataTable: this.dataTable,\n          options: this.mergeOptions()\n        });\n        this.registerChartEvents();\n        this.wrapperReadySubject.next(this.wrapper);\n        this.initialized = true;\n        this.drawChart();\n      });\n    }\n\n    ngOnChanges(changes) {\n      if (changes.dynamicResize) {\n        this.updateResizeListener();\n      }\n\n      if (this.initialized) {\n        let shouldRedraw = false;\n\n        if (changes.data || changes.columns || changes.formatters) {\n          this.dataTable = this.dataTableService.create(this.data, this.columns, this.formatters);\n          this.wrapper.setDataTable(this.dataTable);\n          shouldRedraw = true;\n        }\n\n        if (changes.type) {\n          this.wrapper.setChartType(this.type);\n          shouldRedraw = true;\n        }\n\n        if (changes.options || changes.width || changes.height || changes.title) {\n          this.wrapper.setOptions(this.mergeOptions());\n          shouldRedraw = true;\n        }\n\n        if (shouldRedraw) {\n          this.drawChart();\n        }\n      }\n    }\n\n    ngOnDestroy() {\n      this.unsubscribeToResizeIfSubscribed();\n    }\n    /**\n     * For listening to events other than the most common ones (available via Output properties).\n     *\n     * Can be called after the chart emits that it's \"ready\".\n     *\n     * Returns a handle that can be used for `removeEventListener`.\n     */\n\n\n    addEventListener(eventName, callback) {\n      const handle = this.registerChartEvent(this.chart, eventName, callback);\n      this.eventListeners.set(handle, {\n        eventName,\n        callback,\n        handle\n      });\n      return handle;\n    }\n\n    removeEventListener(handle) {\n      const entry = this.eventListeners.get(handle);\n\n      if (entry) {\n        google.visualization.events.removeListener(entry.handle);\n        this.eventListeners.delete(handle);\n      }\n    }\n\n    updateResizeListener() {\n      this.unsubscribeToResizeIfSubscribed();\n\n      if (this.dynamicResize) {\n        this.resizeSubscription = fromEvent(window, 'resize', {\n          passive: true\n        }).pipe(debounceTime(100)).subscribe(() => {\n          if (this.initialized) {\n            this.drawChart();\n          }\n        });\n      }\n    }\n\n    unsubscribeToResizeIfSubscribed() {\n      if (this.resizeSubscription != null) {\n        this.resizeSubscription.unsubscribe();\n        this.resizeSubscription = undefined;\n      }\n    }\n\n    mergeOptions() {\n      return {\n        title: this.title,\n        width: this.width,\n        height: this.height,\n        ...this.options\n      };\n    }\n\n    registerChartEvents() {\n      google.visualization.events.removeAllListeners(this.wrapper);\n      this.registerChartEvent(this.wrapper, 'ready', () => {\n        // This could also be done by checking if we already subscribed to the events\n        google.visualization.events.removeAllListeners(this.chart);\n        this.registerChartEvent(this.chart, 'onmouseover', event => this.mouseover.emit(event));\n        this.registerChartEvent(this.chart, 'onmouseout', event => this.mouseleave.emit(event));\n        this.registerChartEvent(this.chart, 'select', () => {\n          const selection = this.chart.getSelection();\n          this.select.emit({\n            selection\n          });\n        });\n        this.eventListeners.forEach(x => x.handle = this.registerChartEvent(this.chart, x.eventName, x.callback));\n        this.ready.emit({\n          chart: this.chart\n        });\n      });\n      this.registerChartEvent(this.wrapper, 'error', error => this.error.emit(error));\n    }\n\n    registerChartEvent(object, eventName, callback) {\n      return google.visualization.events.addListener(object, eventName, callback);\n    }\n\n    drawChart() {\n      if (this.dashboard != null) {\n        // If this chart is part of a dashboard, the dashboard takes care of drawing\n        return;\n      }\n\n      this.wrapper.draw();\n    }\n\n  }\n\n  GoogleChartComponent.ɵfac = function GoogleChartComponent_Factory(t) {\n    return new (t || GoogleChartComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(ScriptLoaderService), i0.ɵɵdirectiveInject(DataTableService), i0.ɵɵdirectiveInject(DashboardComponent, 8));\n  };\n\n  GoogleChartComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: GoogleChartComponent,\n    selectors: [[\"google-chart\"]],\n    hostAttrs: [1, \"google-chart\"],\n    inputs: {\n      type: \"type\",\n      data: \"data\",\n      columns: \"columns\",\n      title: \"title\",\n      width: \"width\",\n      height: \"height\",\n      options: \"options\",\n      formatters: \"formatters\",\n      dynamicResize: \"dynamicResize\"\n    },\n    outputs: {\n      ready: \"ready\",\n      error: \"error\",\n      select: \"select\",\n      mouseover: \"mouseover\",\n      mouseleave: \"mouseleave\"\n    },\n    exportAs: [\"googleChart\"],\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 0,\n    vars: 0,\n    template: function GoogleChartComponent_Template(rf, ctx) {},\n    styles: [\"[_nghost-%COMP%]{width:-webkit-fit-content;width:-moz-fit-content;width:fit-content;display:block}\"],\n    changeDetection: 0\n  });\n  return GoogleChartComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ChartWrapperComponent = /*#__PURE__*/(() => {\n  class ChartWrapperComponent {\n    constructor(element, scriptLoaderService) {\n      this.element = element;\n      this.scriptLoaderService = scriptLoaderService;\n      this.error = new EventEmitter();\n      this.ready = new EventEmitter();\n      this.select = new EventEmitter();\n      this.wrapperReadySubject = new ReplaySubject(1);\n      this.initialized = false;\n    }\n\n    get chart() {\n      return this.chartWrapper.getChart();\n    }\n\n    get wrapperReady$() {\n      return this.wrapperReadySubject.asObservable();\n    }\n\n    get chartWrapper() {\n      if (!this.wrapper) {\n        throw new Error('Cannot access the chart wrapper before initialization.');\n      }\n\n      return this.wrapper;\n    }\n\n    set chartWrapper(wrapper) {\n      this.wrapper = wrapper;\n      this.drawChart();\n    }\n\n    ngOnInit() {\n      // We don't need to load any chart packages, the chart wrapper will handle this else for us\n      this.scriptLoaderService.loadChartPackages().subscribe(() => {\n        if (!this.specs) {\n          this.specs = {};\n        }\n\n        const {\n          containerId,\n          container,\n          ...specs\n        } = this.specs; // Only ever create the wrapper once to allow animations to happen if something changes.\n\n        this.wrapper = new google.visualization.ChartWrapper({ ...specs,\n          container: this.element.nativeElement\n        });\n        this.registerChartEvents();\n        this.wrapperReadySubject.next(this.wrapper);\n        this.drawChart();\n        this.initialized = true;\n      });\n    }\n\n    ngOnChanges(changes) {\n      if (!this.initialized) {\n        return;\n      }\n\n      if (changes.specs) {\n        this.updateChart();\n        this.drawChart();\n      }\n    }\n\n    updateChart() {\n      if (!this.specs) {\n        // When creating the wrapper with empty specs, the google charts library will show an error\n        // If we don't do this, a javascript error will be thrown, which is not as visible to the user\n        this.specs = {};\n      } // The typing here are not correct. These methods accept `undefined` as well.\n      // That's why we have to cast to `any`\n\n\n      this.wrapper.setChartType(this.specs.chartType);\n      this.wrapper.setDataTable(this.specs.dataTable);\n      this.wrapper.setDataSourceUrl(this.specs.dataSourceUrl);\n      this.wrapper.setDataSourceUrl(this.specs.dataSourceUrl);\n      this.wrapper.setQuery(this.specs.query);\n      this.wrapper.setOptions(this.specs.options);\n      this.wrapper.setRefreshInterval(this.specs.refreshInterval);\n      this.wrapper.setView(this.specs.view);\n    }\n\n    drawChart() {\n      if (this.wrapper) {\n        this.wrapper.draw();\n      }\n    }\n\n    registerChartEvents() {\n      google.visualization.events.removeAllListeners(this.wrapper);\n\n      const registerChartEvent = (object, eventName, callback) => {\n        google.visualization.events.addListener(object, eventName, callback);\n      };\n\n      registerChartEvent(this.wrapper, 'ready', () => this.ready.emit({\n        chart: this.chart\n      }));\n      registerChartEvent(this.wrapper, 'error', error => this.error.emit(error));\n      registerChartEvent(this.wrapper, 'select', () => {\n        const selection = this.chart.getSelection();\n        this.select.emit({\n          selection\n        });\n      });\n    }\n\n  }\n\n  ChartWrapperComponent.ɵfac = function ChartWrapperComponent_Factory(t) {\n    return new (t || ChartWrapperComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(ScriptLoaderService));\n  };\n\n  ChartWrapperComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ChartWrapperComponent,\n    selectors: [[\"chart-wrapper\"]],\n    hostAttrs: [1, \"chart-wrapper\"],\n    inputs: {\n      specs: \"specs\"\n    },\n    outputs: {\n      error: \"error\",\n      ready: \"ready\",\n      select: \"select\"\n    },\n    exportAs: [\"chartWrapper\"],\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 0,\n    vars: 0,\n    template: function ChartWrapperComponent_Template(rf, ctx) {},\n    styles: [_c1],\n    changeDetection: 0\n  });\n  return ChartWrapperComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet GoogleChartsModule = /*#__PURE__*/(() => {\n  class GoogleChartsModule {\n    static forRoot(config = {}) {\n      return {\n        ngModule: GoogleChartsModule,\n        providers: [{\n          provide: GOOGLE_CHARTS_CONFIG,\n          useValue: config\n        }]\n      };\n    }\n\n  }\n\n  GoogleChartsModule.ɵfac = function GoogleChartsModule_Factory(t) {\n    return new (t || GoogleChartsModule)();\n  };\n\n  GoogleChartsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: GoogleChartsModule\n  });\n  GoogleChartsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [ScriptLoaderService]\n  });\n  return GoogleChartsModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Public API Surface of angular-google-charts\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { ChartEditorComponent, ChartEditorRef, ChartType, ChartWrapperComponent, ControlWrapperComponent, DashboardComponent, FilterType, GOOGLE_CHARTS_CONFIG, GOOGLE_CHARTS_LAZY_CONFIG, GoogleChartComponent, GoogleChartsModule, ScriptLoaderService, getDefaultConfig, getPackageForChart }; //# sourceMappingURL=angular-google-charts.mjs.map","map":null,"metadata":{},"sourceType":"module"}